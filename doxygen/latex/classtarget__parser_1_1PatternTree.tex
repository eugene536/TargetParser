\hypertarget{classtarget__parser_1_1PatternTree}{}\section{target\+\_\+parser\+:\+:Pattern\+Tree Class Reference}
\label{classtarget__parser_1_1PatternTree}\index{target\+\_\+parser\+::\+Pattern\+Tree@{target\+\_\+parser\+::\+Pattern\+Tree}}


Класс представляющий разобранное выражение в виде дерева, возвращается из метода \hyperlink{namespacetarget__parser_a3e0ffa10d4fd38f05986d81c0529fdc1}{Parse }.  




{\ttfamily \#include $<$Pattern\+Tree.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bfseries Pattern\+Tree} (const \hyperlink{classtarget__parser_1_1PatternTree}{Pattern\+Tree} \&rhs)\hypertarget{classtarget__parser_1_1PatternTree_a2de6f22b3c103c7d6e8ab42d3208ad44}{}\label{classtarget__parser_1_1PatternTree_a2de6f22b3c103c7d6e8ab42d3208ad44}

\item 
\hyperlink{classtarget__parser_1_1PatternTree}{Pattern\+Tree} \& \hyperlink{classtarget__parser_1_1PatternTree_a52d2823b79a76e29e9ddd8d6cadba634}{operator=} (const \hyperlink{classtarget__parser_1_1PatternTree}{Pattern\+Tree} \&rhs)\hypertarget{classtarget__parser_1_1PatternTree_a52d2823b79a76e29e9ddd8d6cadba634}{}\label{classtarget__parser_1_1PatternTree_a52d2823b79a76e29e9ddd8d6cadba634}

\begin{DoxyCompactList}\small\item\em полностью копирует дерево \end{DoxyCompactList}\item 
void \hyperlink{classtarget__parser_1_1PatternTree_a851ee4b1279c2dcfc4557cab03f8aa83}{For\+Each\+Vertex} (const \hyperlink{namespacetarget__parser_aa28dbbced739f360834455cbffeaa6e4}{Func} \&func) const 
\begin{DoxyCompactList}\small\item\em вызывает функцию func на каждой из терминальных вершин дерева, передавая ей состояние вершины \end{DoxyCompactList}\item 
void \hyperlink{classtarget__parser_1_1PatternTree_a931c01fcdabeedc5b6bdf651c544b1ab}{Set\+Value} (int pos, bool value)
\begin{DoxyCompactList}\small\item\em обновляет значение в вершине с номером pos. \end{DoxyCompactList}\item 
bool \hyperlink{classtarget__parser_1_1PatternTree_afb6cc7464f4df5eca028edfb6fd6d222}{Calculate} () const 
\begin{DoxyCompactList}\small\item\em считает значение для всего логического выражения, представленного в виде дерева \end{DoxyCompactList}\item 
std\+::string \hyperlink{classtarget__parser_1_1PatternTree_ab73d10f856192a4e6147c06c383302d1}{To\+String} () const 
\begin{DoxyCompactList}\small\item\em конвертирует дерево в строковое представление, расставляя скобки около всех операций \end{DoxyCompactList}\item 
bool \hyperlink{classtarget__parser_1_1PatternTree_a4732f8e97b9e85e7072b21b4e0cb6bbd}{Is\+Valid} () const 
\begin{DoxyCompactList}\small\item\em возвращает true, в случае если дерево валидно распарсилось и готово к использованию \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
std\+::ostream \& {\bfseries operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classtarget__parser_1_1PatternTree}{Pattern\+Tree} \&pt)\hypertarget{classtarget__parser_1_1PatternTree_aaaaf63cb27d3e6f0295946db934787cb}{}\label{classtarget__parser_1_1PatternTree_aaaaf63cb27d3e6f0295946db934787cb}

\item 
\hyperlink{classtarget__parser_1_1PatternTree}{Pattern\+Tree} \hyperlink{classtarget__parser_1_1PatternTree_afbef828a1da57a807431665a6be3cfb1}{Parse} (char const $\ast$first, size\+\_\+t len, int $\ast$pos\+\_\+unparsed)
\begin{DoxyCompactList}\small\item\em разбирает строку по соответствующей грамматике и строит для нее дерево разбора \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Класс представляющий разобранное выражение в виде дерева, возвращается из метода \hyperlink{namespacetarget__parser_a3e0ffa10d4fd38f05986d81c0529fdc1}{Parse }. 

\subsection{Member Function Documentation}
\index{target\+\_\+parser\+::\+Pattern\+Tree@{target\+\_\+parser\+::\+Pattern\+Tree}!Calculate@{Calculate}}
\index{Calculate@{Calculate}!target\+\_\+parser\+::\+Pattern\+Tree@{target\+\_\+parser\+::\+Pattern\+Tree}}
\subsubsection[{\texorpdfstring{Calculate() const }{Calculate() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool target\+\_\+parser\+::\+Pattern\+Tree\+::\+Calculate (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classtarget__parser_1_1PatternTree_afb6cc7464f4df5eca028edfb6fd6d222}{}\label{classtarget__parser_1_1PatternTree_afb6cc7464f4df5eca028edfb6fd6d222}


считает значение для всего логического выражения, представленного в виде дерева 

\begin{DoxyReturn}{Returns}
значение логического выражения 
\end{DoxyReturn}
\index{target\+\_\+parser\+::\+Pattern\+Tree@{target\+\_\+parser\+::\+Pattern\+Tree}!For\+Each\+Vertex@{For\+Each\+Vertex}}
\index{For\+Each\+Vertex@{For\+Each\+Vertex}!target\+\_\+parser\+::\+Pattern\+Tree@{target\+\_\+parser\+::\+Pattern\+Tree}}
\subsubsection[{\texorpdfstring{For\+Each\+Vertex(const Func \&func) const }{ForEachVertex(const Func &func) const }}]{\setlength{\rightskip}{0pt plus 5cm}void target\+\_\+parser\+::\+Pattern\+Tree\+::\+For\+Each\+Vertex (
\begin{DoxyParamCaption}
\item[{const {\bf Func} \&}]{func}
\end{DoxyParamCaption}
) const}\hypertarget{classtarget__parser_1_1PatternTree_a851ee4b1279c2dcfc4557cab03f8aa83}{}\label{classtarget__parser_1_1PatternTree_a851ee4b1279c2dcfc4557cab03f8aa83}


вызывает функцию func на каждой из терминальных вершин дерева, передавая ей состояние вершины 


\begin{DoxyParams}{Parameters}
{\em func} & функтор который будет вызываться \\
\hline
\end{DoxyParams}
\index{target\+\_\+parser\+::\+Pattern\+Tree@{target\+\_\+parser\+::\+Pattern\+Tree}!Is\+Valid@{Is\+Valid}}
\index{Is\+Valid@{Is\+Valid}!target\+\_\+parser\+::\+Pattern\+Tree@{target\+\_\+parser\+::\+Pattern\+Tree}}
\subsubsection[{\texorpdfstring{Is\+Valid() const }{IsValid() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool target\+\_\+parser\+::\+Pattern\+Tree\+::\+Is\+Valid (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classtarget__parser_1_1PatternTree_a4732f8e97b9e85e7072b21b4e0cb6bbd}{}\label{classtarget__parser_1_1PatternTree_a4732f8e97b9e85e7072b21b4e0cb6bbd}


возвращает true, в случае если дерево валидно распарсилось и готово к использованию 

\begin{DoxyReturn}{Returns}
готовность дерева к использованию 
\end{DoxyReturn}
\index{target\+\_\+parser\+::\+Pattern\+Tree@{target\+\_\+parser\+::\+Pattern\+Tree}!Set\+Value@{Set\+Value}}
\index{Set\+Value@{Set\+Value}!target\+\_\+parser\+::\+Pattern\+Tree@{target\+\_\+parser\+::\+Pattern\+Tree}}
\subsubsection[{\texorpdfstring{Set\+Value(int pos, bool value)}{SetValue(int pos, bool value)}}]{\setlength{\rightskip}{0pt plus 5cm}void target\+\_\+parser\+::\+Pattern\+Tree\+::\+Set\+Value (
\begin{DoxyParamCaption}
\item[{int}]{pos, }
\item[{bool}]{value}
\end{DoxyParamCaption}
)}\hypertarget{classtarget__parser_1_1PatternTree_a931c01fcdabeedc5b6bdf651c544b1ab}{}\label{classtarget__parser_1_1PatternTree_a931c01fcdabeedc5b6bdf651c544b1ab}


обновляет значение в вершине с номером pos. 


\begin{DoxyParams}{Parameters}
{\em pos} & номер вершины, который можно получить при вызове функции \hyperlink{classtarget__parser_1_1PatternTree_a851ee4b1279c2dcfc4557cab03f8aa83}{For\+Each\+Vertex(const Func\& func) const} \\
\hline
{\em value} & новое значение для вершины \\
\hline
\end{DoxyParams}
\index{target\+\_\+parser\+::\+Pattern\+Tree@{target\+\_\+parser\+::\+Pattern\+Tree}!To\+String@{To\+String}}
\index{To\+String@{To\+String}!target\+\_\+parser\+::\+Pattern\+Tree@{target\+\_\+parser\+::\+Pattern\+Tree}}
\subsubsection[{\texorpdfstring{To\+String() const }{ToString() const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string target\+\_\+parser\+::\+Pattern\+Tree\+::\+To\+String (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classtarget__parser_1_1PatternTree_ab73d10f856192a4e6147c06c383302d1}{}\label{classtarget__parser_1_1PatternTree_ab73d10f856192a4e6147c06c383302d1}


конвертирует дерево в строковое представление, расставляя скобки около всех операций 

\begin{DoxyReturn}{Returns}
строковое представление дерева 
\end{DoxyReturn}


\subsection{Friends And Related Function Documentation}
\index{target\+\_\+parser\+::\+Pattern\+Tree@{target\+\_\+parser\+::\+Pattern\+Tree}!Parse@{Parse}}
\index{Parse@{Parse}!target\+\_\+parser\+::\+Pattern\+Tree@{target\+\_\+parser\+::\+Pattern\+Tree}}
\subsubsection[{\texorpdfstring{Parse}{Parse}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pattern\+Tree} Parse (
\begin{DoxyParamCaption}
\item[{char const $\ast$}]{first, }
\item[{size\+\_\+t}]{len, }
\item[{int $\ast$}]{pos\+\_\+unparsed}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{classtarget__parser_1_1PatternTree_afbef828a1da57a807431665a6be3cfb1}{}\label{classtarget__parser_1_1PatternTree_afbef828a1da57a807431665a6be3cfb1}


разбирает строку по соответствующей грамматике и строит для нее дерево разбора 


\begin{DoxyParams}{Parameters}
{\em first} & указатель на начало строки \\
\hline
{\em len} & длина строки \\
\hline
{\em pos\+\_\+unparsed} & если не равен nullptr, в случае ошибки (\hyperlink{classtarget__parser_1_1PatternTree_a4732f8e97b9e85e7072b21b4e0cb6bbd}{Is\+Valid } == false), указывает на первый неразобранный символ \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
разобранное дерево, нужно проверить его, что он в валидном состоянии(строка распарсилась) 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/nemchenko/work/tasks/sorm/sorm-\/probe/lib/\+Target\+Parser/include/\hyperlink{PatternTree_8h}{Pattern\+Tree.\+h}\end{DoxyCompactItemize}
